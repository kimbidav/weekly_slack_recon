<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipeline Reconciliation Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f7fa;
            color: #333;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }

        .header-content {
            flex: 1;
        }

        h1 {
            color: #1a1a1a;
            margin-bottom: 8px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            font-size: 14px;
        }

        .generate-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
        }

        .generate-btn {
            padding: 12px 24px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .generate-btn:hover:not(:disabled) {
            background: #357abd;
        }

        .generate-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .progress-indicator {
            font-size: 12px;
            color: #666;
            min-height: 16px;
        }

        .progress-indicator.active {
            color: #4a90e2;
        }

        .progress-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4a90e2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 6px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 32px;
            font-weight: 600;
            color: #1a1a1a;
        }

        .stat-value.closed { color: #d62728; }
        .stat-value.explicit { color: #2ca02c; }
        .stat-value.unclear { color: #ff7f0e; }
        .stat-value.followup { color: #e377c2; }

        .filters {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 24px;
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .filter-group label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }

        select, input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        .search-box {
            flex: 1;
            min-width: 200px;
        }

        /* Multi-select status filter */
        .multi-select {
            position: relative;
            min-width: 220px;
        }

        .multi-select-toggle {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            user-select: none;
            min-height: 38px;
        }

        .multi-select-toggle:hover {
            border-color: #bbb;
        }

        .multi-select-toggle:focus-within,
        .multi-select.open .multi-select-toggle {
            border-color: #4a90e2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        .multi-select-toggle .arrow {
            font-size: 10px;
            color: #999;
            transition: transform 0.2s;
        }

        .multi-select.open .multi-select-toggle .arrow {
            transform: rotate(180deg);
        }

        .multi-select-dropdown {
            display: none;
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 100;
            padding: 4px 0;
        }

        .multi-select.open .multi-select-dropdown {
            display: block;
        }

        .multi-select-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.15s;
        }

        .multi-select-option:hover {
            background: #f5f7fa;
        }

        .multi-select-option input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
            accent-color: #4a90e2;
        }

        .multi-select-option label {
            cursor: pointer;
            flex: 1;
            font-size: 13px;
        }

        .multi-select-divider {
            height: 1px;
            background: #eee;
            margin: 4px 0;
        }

        .selected-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            flex: 1;
            min-width: 0;
        }

        .selected-tag {
            display: inline-flex;
            align-items: center;
            background: #e8f0fe;
            color: #1a73e8;
            border-radius: 3px;
            padding: 1px 6px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
        }

        .selected-placeholder {
            color: #999;
            font-size: 14px;
        }

        .table-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        th {
            padding: 12px 16px;
            text-align: left;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            color: #666;
            letter-spacing: 0.5px;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        th:hover {
            background: #e9ecef;
        }

        th.sortable::after {
            content: ' ↕';
            opacity: 0.3;
            font-size: 10px;
        }

        th.sort-asc::after {
            content: ' ↑';
            opacity: 1;
            color: #4a90e2;
        }

        th.sort-desc::after {
            content: ' ↓';
            opacity: 1;
            color: #4a90e2;
        }

        td {
            padding: 12px 16px;
            border-bottom: 1px solid #f0f0f0;
        }

        tbody tr:hover {
            background: #f8f9fa;
        }

        tbody tr:last-child td {
            border-bottom: none;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-closed {
            background: #fee;
            color: #c33;
        }

        .status-explicit {
            background: #efe;
            color: #2a7;
        }

        .status-unclear {
            background: #ffe;
            color: #fa5;
        }

        .followup-badge {
            background: #fef;
            color: #c39;
            margin-left: 8px;
            font-size: 10px;
        }

        a {
            color: #4a90e2;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .days-old {
            color: #666;
            font-size: 12px;
        }

        .empty-state {
            padding: 60px 20px;
            text-align: center;
            color: #999;
        }

        .error-state {
            padding: 40px 20px;
            text-align: center;
            color: #d62728;
            background: #fee;
            border-radius: 8px;
            margin: 20px 0;
        }

        .loading {
            padding: 40px;
            text-align: center;
            color: #666;
        }

        /* Checkbox column */
        th.col-select, td.col-select {
            width: 40px;
            text-align: center;
            cursor: default;
        }

        th.col-select {
            cursor: default;
        }

        td.col-select input[type="checkbox"] {
            cursor: pointer;
            accent-color: #4a90e2;
            width: 16px;
            height: 16px;
        }

        /* Follow-up bar (sticky bottom) */
        .followup-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 2px solid #4a90e2;
            box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
            padding: 14px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 200;
            transform: translateY(100%);
            transition: transform 0.25s ease;
        }

        .followup-bar.visible {
            transform: translateY(0);
        }

        .followup-bar .bar-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .followup-bar .selection-count {
            font-weight: 600;
            font-size: 14px;
            color: #333;
        }

        .followup-bar .clear-btn {
            font-size: 13px;
            color: #999;
            background: none;
            border: none;
            cursor: pointer;
            text-decoration: underline;
        }

        .followup-bar .clear-btn:hover {
            color: #666;
        }

        .followup-bar .preview-btn {
            padding: 10px 20px;
            background: #2ca02c;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .followup-bar .preview-btn:hover {
            background: #248a24;
        }

        /* Follow-up preview panel */
        .followup-panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 24px;
            margin-bottom: 80px;
            overflow: hidden;
            display: none;
        }

        .followup-panel.visible {
            display: block;
        }

        .followup-panel-header {
            background: #f8f9fa;
            padding: 16px 20px;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .followup-panel-header h2 {
            font-size: 16px;
            color: #333;
            margin: 0;
        }

        .followup-panel-header .close-panel-btn {
            background: none;
            border: none;
            font-size: 20px;
            color: #999;
            cursor: pointer;
            padding: 0 4px;
        }

        .followup-panel-header .close-panel-btn:hover {
            color: #333;
        }

        .channel-message-block {
            padding: 20px;
            border-bottom: 1px solid #eee;
        }

        .channel-message-block:last-child {
            border-bottom: none;
        }

        .channel-message-block h3 {
            font-size: 14px;
            color: #4a90e2;
            margin-bottom: 10px;
        }

        .channel-message-block textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
            color: #333;
        }

        .channel-message-block textarea:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        .channel-send-row {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 10px;
        }

        .channel-send-btn {
            padding: 8px 16px;
            background: #2ca02c;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .channel-send-btn:hover:not(:disabled) {
            background: #248a24;
        }

        .channel-send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .channel-send-btn.sent {
            background: #4a90e2;
        }

        .send-status {
            font-size: 13px;
            font-weight: 500;
        }

        .send-status.success {
            color: #2ca02c;
        }

        .send-status.error {
            color: #d62728;
        }

        .send-all-row {
            padding: 16px 20px;
            background: #f8f9fa;
            border-top: 2px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
        }

        .send-all-btn {
            padding: 10px 24px;
            background: #2ca02c;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .send-all-btn:hover:not(:disabled) {
            background: #248a24;
        }

        .send-all-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* AI Enrichment styles */
        .enrich-btn {
            padding: 12px 24px;
            background: #7c3aed;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .enrich-btn:hover:not(:disabled) {
            background: #6d28d9;
        }

        .enrich-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .enrich-progress {
            font-size: 12px;
            color: #666;
            min-height: 16px;
        }

        .enrich-progress.active {
            color: #7c3aed;
        }

        .enrich-progress-bar-container {
            width: 100%;
            max-width: 260px;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 6px;
            display: none;
        }

        .enrich-progress-bar-container.active {
            display: block;
        }

        .enrich-progress-bar {
            height: 100%;
            background: #7c3aed;
            border-radius: 4px;
            transition: width 0.4s ease;
            width: 0%;
        }

        .ai-status-cell {
            max-width: 300px;
            min-width: 180px;
        }

        .ai-summary-text {
            font-size: 12px;
            color: #444;
            line-height: 1.5;
        }

        .ai-summary-list {
            font-size: 12px;
            color: #444;
            line-height: 1.5;
            margin: 0;
            padding-left: 16px;
            list-style: disc;
        }

        .ai-summary-list li {
            margin-bottom: 3px;
        }

        .ai-enriched-at {
            font-size: 10px;
            color: #aaa;
            margin-top: 3px;
        }


        .header-buttons {
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
        }

        /* Thread side panel */
        .thread-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.25);
            z-index: 300;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
        }

        .thread-panel-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .thread-panel {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 440px;
            max-width: 90vw;
            background: white;
            box-shadow: -4px 0 20px rgba(0,0,0,0.15);
            z-index: 301;
            transform: translateX(100%);
            transition: transform 0.25s ease;
            display: flex;
            flex-direction: column;
        }

        .thread-panel.visible {
            transform: translateX(0);
        }

        .thread-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid #e9ecef;
            flex-shrink: 0;
        }

        .thread-panel-header h2 {
            font-size: 15px;
            color: #333;
            margin: 0;
            font-weight: 600;
        }

        .thread-panel-header .thread-channel {
            font-size: 12px;
            color: #888;
            font-weight: 400;
            margin-top: 2px;
        }

        .thread-panel-header-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .thread-panel-header .open-slack-link {
            font-size: 12px;
            color: #4a90e2;
            text-decoration: none;
        }

        .thread-panel-header .open-slack-link:hover {
            text-decoration: underline;
        }

        .thread-panel-header .close-thread-btn {
            background: none;
            border: none;
            font-size: 22px;
            color: #999;
            cursor: pointer;
            padding: 0 4px;
            line-height: 1;
        }

        .thread-panel-header .close-thread-btn:hover {
            color: #333;
        }

        .thread-panel-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
        }

        .thread-loading {
            text-align: center;
            color: #888;
            padding: 40px 0;
            font-size: 14px;
        }

        .thread-error {
            text-align: center;
            color: #d62728;
            padding: 40px 20px;
            font-size: 13px;
        }

        .thread-msg {
            margin-bottom: 16px;
        }

        .thread-msg.parent-msg {
            padding-bottom: 14px;
            border-bottom: 1px solid #eee;
            margin-bottom: 18px;
        }

        .thread-msg-author {
            font-weight: 600;
            font-size: 13px;
            color: #1a1a1a;
            display: inline;
        }

        .thread-msg-time {
            font-size: 11px;
            color: #aaa;
            margin-left: 8px;
        }

        .thread-msg-text {
            font-size: 13px;
            color: #333;
            line-height: 1.55;
            margin-top: 4px;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .thread-msg-text a {
            color: #4a90e2;
            text-decoration: none;
        }

        .thread-msg-text a:hover {
            text-decoration: underline;
        }

        .thread-msg-text .slack-bold {
            font-weight: 600;
        }

        .thread-msg-text .slack-italic {
            font-style: italic;
        }

        .thread-msg-text .slack-code {
            font-family: 'SF Mono', 'Menlo', 'Monaco', monospace;
            font-size: 12px;
            background: #f5f5f5;
            padding: 1px 4px;
            border-radius: 3px;
        }

        .thread-msg-text .slack-mention {
            color: #4a90e2;
            background: #e8f0fe;
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: 500;
        }

        .thread-reply-count {
            font-size: 12px;
            color: #888;
            padding: 4px 0 8px;
        }

        /* Thread message composer */
        .thread-composer {
            position: relative;
            border-top: 1px solid #e9ecef;
            padding: 16px 20px;
            background: #f8f9fa;
            flex-shrink: 0;
        }

        .thread-composer-textarea {
            width: 100%;
            min-height: 80px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            color: #333;
            background: white;
        }

        .thread-composer-textarea:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        .thread-composer-actions {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 10px;
        }

        .thread-composer-help {
            font-size: 11px;
            color: #888;
        }

        .thread-send-btn {
            padding: 8px 20px;
            background: #2ca02c;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .thread-send-btn:hover:not(:disabled) {
            background: #248a24;
        }

        .thread-send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .thread-send-status {
            font-size: 12px;
            margin-right: 8px;
        }

        .thread-send-status.success {
            color: #2ca02c;
        }

        .thread-send-status.error {
            color: #d62728;
        }

        /* Mention autocomplete */
        .mention-autocomplete {
            position: absolute;
            bottom: 100%;
            left: 20px;
            right: 20px;
            margin-bottom: 8px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-height: 200px;
            overflow-y: auto;
            z-index: 400;
            display: none;
        }

        .mention-autocomplete.visible {
            display: block;
        }

        .mention-option {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            color: #333;
        }

        .mention-option:hover,
        .mention-option.selected {
            background: #e8f0fe;
        }

        .mention-option-name {
            font-weight: 500;
        }

        /* Source badges */
        .source-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.4px;
            text-transform: uppercase;
            vertical-align: middle;
            margin-left: 6px;
        }

        .source-badge-ashby {
            background: #fff3e0;
            color: #e65100;
            border: 1px solid #ffcc80;
        }

        .source-badge-crosslink {
            background: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #a5d6a7;
            cursor: default;
        }

        /* Ashby row tinting */
        tr.ashby-row {
            background: #fffaf5;
        }

        tr.ashby-row:hover {
            background: #fff3e0 !important;
        }

        /* Pipeline stage info */
        .stage-info {
            color: #555;
        }

        a.stage-info {
            color: #4a90e2;
        }

        .stage-progress {
            color: #aaa;
            font-size: 12px;
            margin-left: 4px;
        }

        /* Ashby import section */
        .ashby-import-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
        }

        .ashby-btn {
            padding: 12px 24px;
            background: #e65100;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .ashby-btn:hover:not(:disabled) {
            background: #bf360c;
        }

        .ashby-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .ashby-progress {
            font-size: 12px;
            color: #666;
            min-height: 16px;
        }

        .ashby-progress.active {
            color: #e65100;
        }

        /* Ashby path input row */
        .ashby-path-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .ashby-path-input {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            width: 280px;
            color: #333;
        }

        .ashby-path-input:focus {
            outline: none;
            border-color: #e65100;
            box-shadow: 0 0 0 3px rgba(230, 81, 0, 0.1);
        }

        /* Stat card for Ashby */
        .stat-value.ashby-count { color: #e65100; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <h1>Pipeline Reconciliation Dashboard</h1>
                <div class="subtitle" id="generated-at">Loading...</div>
            </div>
            <div class="header-buttons">
                <div class="button-group">
                    <button class="generate-btn" id="generate-btn" onclick="generateData()">Sync Slack</button>
                    <div class="progress-indicator" id="progress-indicator"></div>
                </div>
                <div class="ashby-import-section">
                    <div class="ashby-path-row">
                        <input type="text" class="ashby-path-input" id="ashby-path-input"
                            placeholder="Path to Ashby output folder…"
                            title="Folder path: picks the latest .json automatically. Or paste a specific file path.">
                        <button class="ashby-btn" id="ashby-btn" onclick="importFromAshby()">Import Ashby</button>
                    </div>
                    <div class="ashby-progress" id="ashby-progress"></div>
                </div>
                <div class="button-group">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <button class="enrich-btn" id="enrich-btn" onclick="startEnrichment()">Enrich with AI</button>
                        <button onclick="clearAiSummaries()" style="background: none; border: 1px solid #ddd; border-radius: 5px; padding: 8px 12px; font-size: 12px; color: #888; cursor: pointer;" title="Remove all AI summaries">Clear</button>
                    </div>
                    <div class="enrich-progress" id="enrich-progress"></div>
                    <div class="enrich-progress-bar-container" id="enrich-bar-container">
                        <div class="enrich-progress-bar" id="enrich-bar"></div>
                    </div>
                </div>
            </div>
        </header>

        <div class="stats" id="stats">
            <div class="stat-card">
                <div class="stat-label">Total Submissions</div>
                <div class="stat-value" id="stat-total">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Closed</div>
                <div class="stat-value closed" id="stat-closed">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">In Process (Explicit)</div>
                <div class="stat-value explicit" id="stat-explicit">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">In Process (Unclear)</div>
                <div class="stat-value unclear" id="stat-unclear">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Needs Follow-up</div>
                <div class="stat-value followup" id="stat-followup">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">In Ashby</div>
                <div class="stat-value ashby-count" id="stat-ashby">0</div>
            </div>
        </div>

        <div class="filters">
            <div class="filter-group">
                <label>Status</label>
                <div class="multi-select" id="status-multi-select">
                    <div class="multi-select-toggle" tabindex="0">
                        <div class="selected-tags">
                            <span class="selected-placeholder">All Statuses</span>
                        </div>
                        <span class="arrow">▼</span>
                    </div>
                    <div class="multi-select-dropdown">
                        <div class="multi-select-option" data-value="">
                            <input type="checkbox" id="status-all" checked>
                            <label for="status-all">All Statuses</label>
                        </div>
                        <div class="multi-select-divider"></div>
                        <div class="multi-select-option" data-value="CLOSED">
                            <input type="checkbox" id="status-closed">
                            <label for="status-closed">CLOSED</label>
                        </div>
                        <div class="multi-select-option" data-value="IN PROCESS — explicit">
                            <input type="checkbox" id="status-explicit">
                            <label for="status-explicit">IN PROCESS — explicit</label>
                        </div>
                        <div class="multi-select-option" data-value="IN PROCESS — unclear">
                            <input type="checkbox" id="status-unclear">
                            <label for="status-unclear">IN PROCESS — unclear</label>
                        </div>
                    </div>
                </div>
            </div>
            <div class="filter-group">
                <label>Channel</label>
                <select id="filter-channel">
                    <option value="">All Channels</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Source</label>
                <select id="filter-source">
                    <option value="">All Sources</option>
                    <option value="slack">Slack only</option>
                    <option value="ashby">Ashby only</option>
                </select>
            </div>
            <div class="filter-group search-box">
                <label>Search Candidate</label>
                <input type="text" id="search" placeholder="Search by name, company, or job…">
            </div>
        </div>

        <div class="table-container">
            <div id="loading" class="loading">Loading data...</div>
            <div id="error" class="error-state" style="display: none;"></div>
            <div id="empty" class="empty-state" style="display: none;">No submissions match the current filters.</div>
            <table id="data-table" style="display: none;">
                <thead>
                    <tr>
                        <th class="col-select"></th>
                        <th class="sortable" data-sort="candidate_name">Candidate</th>
                        <th class="sortable" data-sort="channel_name">Channel / Company</th>
                        <th class="sortable" data-sort="status">Status</th>
                        <th>AI Summary</th>
                        <th class="sortable" data-sort="days_since_submission">Days</th>
                        <th>LinkedIn</th>
                        <th>Stage / Thread</th>
                    </tr>
                </thead>
                <tbody id="table-body">
                </tbody>
            </table>
        </div>

        <!-- Follow-up preview panel -->
        <div class="followup-panel" id="followup-panel">
            <div class="followup-panel-header">
                <h2>Follow-up Messages Preview</h2>
                <button class="close-panel-btn" onclick="closeFollowupPanel()">&times;</button>
            </div>
            <div id="followup-messages"></div>
            <div class="send-all-row">
                <span class="send-status" id="send-all-status"></span>
                <button class="send-all-btn" id="send-all-btn" onclick="sendAllFollowups()">Send All</button>
            </div>
        </div>
    </div>

    <!-- Sticky bottom bar -->
    <div class="followup-bar" id="followup-bar">
        <div class="bar-left">
            <span class="selection-count" id="selection-count">0 candidates selected</span>
            <button class="clear-btn" onclick="clearSelections()">Clear</button>
        </div>
        <button class="preview-btn" onclick="showFollowupPreview()">Preview Follow-up</button>
    </div>

    <!-- Thread side panel -->
    <div class="thread-panel-overlay" id="thread-overlay" onclick="closeThreadPanel()"></div>
    <div class="thread-panel" id="thread-panel">
        <div class="thread-panel-header">
            <div>
                <h2 id="thread-panel-title">Thread</h2>
                <div class="thread-channel" id="thread-panel-channel"></div>
            </div>
            <div class="thread-panel-header-actions">
                <a class="open-slack-link" id="thread-slack-link" href="#" target="_blank">Open in Slack</a>
                <button class="close-thread-btn" onclick="closeThreadPanel()">&times;</button>
            </div>
        </div>
        <div class="thread-panel-body" id="thread-panel-body">
        </div>
        <div class="thread-composer" id="thread-composer">
            <textarea
                class="thread-composer-textarea"
                id="thread-message-input"
                placeholder="Type a message... (use @ to mention people)"
            ></textarea>
            <div class="mention-autocomplete" id="mention-autocomplete"></div>
            <div class="thread-composer-actions">
                <div>
                    <span class="thread-send-status" id="thread-send-status"></span>
                    <span class="thread-composer-help">Use @name to mention people</span>
                </div>
                <button class="thread-send-btn" id="thread-send-btn" onclick="sendThreadMessage()">Send</button>
            </div>
        </div>
    </div>

    <script>
        let allData = [];
        let filteredData = [];
        let sortColumn = 'candidate_name';
        let sortDirection = 'asc';
        let selectedSet = new Set(); // tracks selected submission keys

        function submissionKey(s) {
            if ((s.source || 'slack') === 'ashby') {
                return `ashby::${s.ashby_application_id || s.candidate_name}::${s.submitted_at}`;
            }
            return `${s.channel_id}::${s.candidate_name}::${s.submitted_at}`;
        }

        // Load JSON data
        async function loadData() {
            try {
                // Add cache-busting query param to ensure we get fresh data
                const jsonPath = `weekly_slack_reconciliation.json?t=${Date.now()}`;
                const response = await fetch(jsonPath);
                if (!response.ok) {
                    if (response.status === 404) {
                        // No data file yet - show message to generate
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('error').style.display = 'block';
                        document.getElementById('error').innerHTML = 
                            'No data file found. Click "Generate Data" to start the reconciliation process.';
                        document.getElementById('error').style.color = '#666';
                        document.getElementById('error').style.background = '#f8f9fa';
                        return;
                    }
                    throw new Error(`Failed to load ${jsonPath}`);
                }
                const data = await response.json();
                
                document.getElementById('loading').style.display = 'none';
                
                if (data.generated_at) {
                    const date = new Date(data.generated_at);
                    document.getElementById('generated-at').textContent = 
                        `Generated: ${date.toLocaleString()}`;
                }
                
                // Backfill source field for older records that predate this feature
                allData = (data.submissions || []).map(s => ({
                    source: 'slack',
                    ...s,
                }));
                initializeFilters();
                updateStats();
                applyFilters();
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error: ${error.message}`;
            }
        }

        function initializeFilters() {
            const channelSelect = document.getElementById('filter-channel');
            const currentValue = channelSelect.value; // preserve selection
            // Only show channels from Slack candidates (Ashby candidates have no channel)
            const channels = [...new Set(
                allData.filter(s => s.channel_name).map(s => s.channel_name)
            )].sort();

            // Clear existing options (keep the "All Channels" option)
            while (channelSelect.options.length > 1) {
                channelSelect.remove(1);
            }

            channels.forEach(channel => {
                const option = document.createElement('option');
                option.value = channel;
                option.textContent = formatChannelName(channel);
                channelSelect.appendChild(option);
            });

            // Restore previous selection if still valid
            channelSelect.value = currentValue;
        }

        function updateStats() {
            const total = allData.length;
            const closed = allData.filter(s => s.status === 'CLOSED').length;
            const explicit = allData.filter(s => s.status === 'IN PROCESS — explicit').length;
            const unclear = allData.filter(s => s.status === 'IN PROCESS — unclear').length;
            const followup = allData.filter(s => s.needs_followup).length;
            const ashbyCount = allData.filter(s => s.source === 'ashby').length;

            document.getElementById('stat-total').textContent = total;
            document.getElementById('stat-closed').textContent = closed;
            document.getElementById('stat-explicit').textContent = explicit;
            document.getElementById('stat-unclear').textContent = unclear;
            document.getElementById('stat-followup').textContent = followup;
            document.getElementById('stat-ashby').textContent = ashbyCount;
        }

        function getSelectedStatuses() {
            const allCheckbox = document.getElementById('status-all');
            if (allCheckbox && allCheckbox.checked) return []; // empty = no filter
            const checkboxes = document.querySelectorAll('#status-multi-select .multi-select-option[data-value]:not([data-value=""]) input[type="checkbox"]');
            const selected = [];
            checkboxes.forEach(cb => {
                if (cb.checked) {
                    selected.push(cb.closest('.multi-select-option').dataset.value);
                }
            });
            return selected;
        }

        function applyFilters() {
            const selectedStatuses = getSelectedStatuses();
            const channelFilter = document.getElementById('filter-channel').value;
            const sourceFilter = document.getElementById('filter-source').value;
            const searchTerm = document.getElementById('search').value.toLowerCase();

            filteredData = allData.filter(submission => {
                if (selectedStatuses.length > 0 && !selectedStatuses.includes(submission.status)) return false;
                if (channelFilter && submission.channel_name !== channelFilter) return false;
                if (sourceFilter && (submission.source || 'slack') !== sourceFilter) return false;
                if (searchTerm) {
                    const haystack = [
                        submission.candidate_name,
                        submission.channel_name,
                        submission.company_name,
                        submission.job_title,
                    ].filter(Boolean).join(' ').toLowerCase();
                    if (!haystack.includes(searchTerm)) return false;
                }
                return true;
            });

            sortData();
            renderTable();
        }

        function sortData() {
            filteredData.sort((a, b) => {
                let aVal = a[sortColumn];
                let bVal = b[sortColumn];

                // Handle different data types
                if (typeof aVal === 'string') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }

                if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;
                if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;
                return 0;
            });
        }

        function renderTable() {
            const tbody = document.getElementById('table-body');
            const table = document.getElementById('data-table');
            const empty = document.getElementById('empty');

            if (filteredData.length === 0) {
                table.style.display = 'none';
                empty.style.display = 'block';
                return;
            }

            empty.style.display = 'none';
            table.style.display = 'table';
            tbody.innerHTML = '';

            filteredData.forEach((submission, idx) => {
                try {
                    const row = document.createElement('tr');
                    const isAshby = (submission.source || 'slack') === 'ashby';
                    if (isAshby) row.classList.add('ashby-row');

                    const key = submissionKey(submission);
                    // Only Slack candidates that are active can receive follow-up messages
                    const canSelect = !isAshby && submission.status !== 'CLOSED';
                    const isChecked = selectedSet.has(key);

                    const statusClass = submission.status === 'CLOSED' ? 'status-closed' :
                                       submission.status === 'IN PROCESS — explicit' ? 'status-explicit' :
                                       'status-unclear';

                    const aiCell = renderAiStatusCell(submission);

                    // ── Candidate cell ─────────────────────────────────────
                    let candidateHtml = `<strong>${escapeHtml(submission.candidate_name)}</strong>`;
                    if (isAshby) {
                        candidateHtml += `<span class="source-badge source-badge-ashby" title="From Ashby ATS">Ashby</span>`;
                    }
                    if (submission.also_in_ashby) {
                        candidateHtml += `<span class="source-badge source-badge-crosslink" title="Also found in Ashby">+Ashby</span>`;
                    }
                    if (submission.also_in_slack) {
                        candidateHtml += `<span class="source-badge source-badge-crosslink" title="Also found in Slack">+Slack</span>`;
                    }

                    // ── Channel / Company cell ──────────────────────────────
                    let sourceCell;
                    if (isAshby) {
                        sourceCell = submission.company_name
                            ? escapeHtml(submission.company_name)
                            : '<span style="color:#aaa;">—</span>';
                    } else {
                        sourceCell = submission.channel_name
                            ? escapeHtml(formatChannelName(submission.channel_name))
                            : '<span style="color:#aaa;">—</span>';
                    }

                    // ── Stage / Thread cell ────────────────────────────────
                    let actionCell;
                    if (isAshby) {
                        const ashbyUrl = submission.ashby_candidate_id
                            ? `https://app.ashbyhq.com/candidates/${submission.ashby_candidate_id}`
                            : null;
                        if (submission.pipeline_stage) {
                            const progress = submission.stage_progress
                                ? `<span class="stage-progress">(${escapeHtml(submission.stage_progress)})</span>`
                                : '';
                            const stageText = `${escapeHtml(submission.pipeline_stage)}${progress ? ' ' + progress : ''}`;
                            actionCell = ashbyUrl
                                ? `<a href="${escapeHtml(ashbyUrl)}" target="_blank" class="stage-info">${stageText}</a>`
                                : `<span class="stage-info">${stageText}</span>`;
                        } else {
                            actionCell = ashbyUrl
                                ? `<a href="${escapeHtml(ashbyUrl)}" target="_blank" style="color:#aaa;">View in Ashby</a>`
                                : '<span style="color:#aaa;">—</span>';
                        }
                    } else {
                        actionCell = submission.slack_url
                            ? `<a href="#" onclick="openThreadPanel('${escapeAttr(submission.channel_id)}', '${escapeAttr(submission.slack_url)}', '${escapeAttr(submission.candidate_name)}', '${escapeAttr(submission.channel_name || '')}'); return false;">View Thread</a>`
                            : '—';
                    }

                    // ── Days cell ──────────────────────────────────────────
                    const daysVal = submission.days_since_submission ?? submission.days_in_stage ?? '?';
                    const daysTitle = isAshby ? 'days in current stage' : 'days since submission';

                    row.innerHTML = `
                        <td class="col-select">
                            ${canSelect ? `<input type="checkbox" data-key="${escapeHtml(key)}" ${isChecked ? 'checked' : ''} onchange="toggleSelection(this)">` : ''}
                        </td>
                        <td>${candidateHtml}</td>
                        <td>${sourceCell}</td>
                        <td>
                            <span class="status-badge ${statusClass}">${escapeHtml(submission.status)}</span>
                            ${submission.needs_followup ? '<span class="status-badge followup-badge">Follow-up</span>' : ''}
                        </td>
                        <td class="ai-status-cell">${aiCell}</td>
                        <td><span class="days-old" title="${daysTitle}">${daysVal}d</span></td>
                        <td>${submission.linkedin_url ? `<a href="${escapeHtml(submission.linkedin_url)}" target="_blank">View Profile</a>` : '<span style="color:#aaa;">—</span>'}</td>
                        <td>${actionCell}</td>
                    `;
                    tbody.appendChild(row);
                } catch (err) {
                    console.error(`Error rendering row ${idx} (${submission.candidate_name}):`, err);
                }
            });

            // Update sort indicators
            document.querySelectorAll('th.sortable').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
                if (th.dataset.sort === sortColumn) {
                    th.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatChannelName(channelName) {
            if (!channelName) return '';
            // Strip leading # and common 'candidatelabs-' prefix, then title-case
            const name = channelName.replace(/^#?candidatelabs-/i, '');
            return name.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        }

        // Multi-select status filter logic
        (function initMultiSelect() {
            const container = document.getElementById('status-multi-select');
            const toggle = container.querySelector('.multi-select-toggle');
            const allCheckbox = document.getElementById('status-all');
            const statusCheckboxes = container.querySelectorAll('.multi-select-option[data-value]:not([data-value=""]) input[type="checkbox"]');

            // Toggle dropdown open/close
            toggle.addEventListener('click', (e) => {
                e.stopPropagation();
                container.classList.toggle('open');
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!container.contains(e.target)) {
                    container.classList.remove('open');
                }
            });

            // Close on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') container.classList.remove('open');
            });

            // "All Statuses" checkbox logic
            allCheckbox.addEventListener('change', () => {
                if (allCheckbox.checked) {
                    statusCheckboxes.forEach(cb => cb.checked = false);
                }
                updateToggleDisplay();
                applyFilters();
            });

            // Individual status checkbox logic
            statusCheckboxes.forEach(cb => {
                cb.addEventListener('change', () => {
                    const anyChecked = Array.from(statusCheckboxes).some(c => c.checked);
                    allCheckbox.checked = !anyChecked;
                    // If all individual statuses are unchecked, revert to "All"
                    if (!anyChecked) {
                        allCheckbox.checked = true;
                    }
                    updateToggleDisplay();
                    applyFilters();
                });
            });

            // Prevent label clicks from toggling dropdown
            container.querySelectorAll('.multi-select-option').forEach(opt => {
                opt.addEventListener('click', (e) => {
                    if (e.target.tagName !== 'INPUT') {
                        const cb = opt.querySelector('input[type="checkbox"]');
                        cb.checked = !cb.checked;
                        cb.dispatchEvent(new Event('change'));
                    }
                    e.stopPropagation();
                });
            });

            function updateToggleDisplay() {
                const tagsContainer = container.querySelector('.selected-tags');
                const selected = getSelectedStatuses();

                if (selected.length === 0) {
                    tagsContainer.innerHTML = '<span class="selected-placeholder">All Statuses</span>';
                } else {
                    const shortLabels = {
                        'CLOSED': 'Closed',
                        'IN PROCESS — explicit': 'Explicit',
                        'IN PROCESS — unclear': 'Unclear'
                    };
                    tagsContainer.innerHTML = selected
                        .map(s => `<span class="selected-tag">${shortLabels[s] || s}</span>`)
                        .join('');
                }
            }
        })();

        // --- Ashby Import ---

        async function checkAshbyStatus() {
            try {
                const response = await fetch('/api/ashby/status');
                const data = await response.json();
                const pathInput = document.getElementById('ashby-path-input');
                const progressEl = document.getElementById('ashby-progress');

                if (data.configured && data.path) {
                    pathInput.value = data.path;
                    if (data.exists) {
                        const modDate = new Date(data.modified_at).toLocaleDateString();
                        const filename = data.resolved_file
                            ? data.resolved_file.split('/').pop()
                            : '';
                        progressEl.textContent = `Ready — ${filename} (${modDate})`;
                    } else {
                        progressEl.textContent = 'Configured path not found on disk.';
                    }
                }
            } catch (err) {
                // Non-fatal: silently ignore
            }
        }

        async function importFromAshby() {
            const btn = document.getElementById('ashby-btn');
            const progressEl = document.getElementById('ashby-progress');
            const pathInput = document.getElementById('ashby-path-input');

            let filePath = pathInput.value.trim();
            if (!filePath) {
                progressEl.textContent = 'Enter the path to your Ashby JSON export above.';
                progressEl.className = 'ashby-progress';
                pathInput.focus();
                return;
            }

            btn.disabled = true;
            progressEl.innerHTML = '<span class="progress-spinner"></span>Importing from Ashby…';
            progressEl.className = 'ashby-progress active';

            try {
                const response = await fetch('/api/ashby/import', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: filePath }),
                });
                const result = await response.json();

                if (result.ok) {
                    progressEl.textContent = `✓ Imported ${result.imported} Ashby candidates (${result.total} total)`;
                    progressEl.className = 'ashby-progress';
                    btn.disabled = false;
                    // Reload the table to show the new data
                    await loadData();
                } else {
                    progressEl.textContent = `✗ ${result.error}`;
                    progressEl.className = 'ashby-progress';
                    btn.disabled = false;
                }
            } catch (err) {
                progressEl.textContent = `✗ ${err.message}`;
                progressEl.className = 'ashby-progress';
                btn.disabled = false;
            }
        }

        // Event listeners
        document.getElementById('filter-channel').addEventListener('change', applyFilters);
        document.getElementById('filter-source').addEventListener('change', applyFilters);
        document.getElementById('search').addEventListener('input', applyFilters);

        document.querySelectorAll('th.sortable').forEach(th => {
            th.addEventListener('click', () => {
                const column = th.dataset.sort;
                if (sortColumn === column) {
                    sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    sortColumn = column;
                    sortDirection = 'asc';
                }
                sortData();
                renderTable();
            });
        });

        // Generate data functions
        let statusPollInterval = null;

        async function generateData() {
            const btn = document.getElementById('generate-btn');
            const indicator = document.getElementById('progress-indicator');
            
            btn.disabled = true;
            indicator.innerHTML = '<span class="progress-spinner"></span>Starting generation...';
            indicator.classList.add('active');

            try {
                const response = await fetch('/api/generate');
                if (!response.ok) {
                    throw new Error('Failed to start generation');
                }
                
                // Start polling for status
                statusPollInterval = setInterval(pollStatus, 1000);
                pollStatus(); // Poll immediately
            } catch (error) {
                indicator.textContent = `Error: ${error.message}`;
                indicator.classList.remove('active');
                btn.disabled = false;
            }
        }

        async function pollStatus() {
            try {
                const response = await fetch('/api/status');
                const status = await response.json();
                
                const indicator = document.getElementById('progress-indicator');
                const btn = document.getElementById('generate-btn');
                
                if (status.running) {
                    indicator.innerHTML = `<span class="progress-spinner"></span>${status.progress || 'Processing...'}`;
                    indicator.classList.add('active');
                } else if (status.completed) {
                    indicator.textContent = '✓ Generation complete!';
                    indicator.classList.remove('active');
                    btn.disabled = false;
                    clearInterval(statusPollInterval);
                    statusPollInterval = null;
                    
                    // Reload data after a short delay
                    setTimeout(() => {
                        location.reload();
                    }, 1000);
                } else if (status.error) {
                    indicator.innerHTML = `✗ <strong style="color: #d62728;">Error:</strong> ${escapeHtml(status.error)}`;
                    indicator.style.color = '#d62728';
                    indicator.style.fontWeight = '600';
                    indicator.classList.remove('active');
                    btn.disabled = false;
                    clearInterval(statusPollInterval);
                    statusPollInterval = null;
                    
                    // Also show error in the main error box
                    const errorDiv = document.getElementById('error');
                    if (errorDiv) {
                        errorDiv.style.display = 'block';
                        errorDiv.textContent = status.error;
                    }
                } else {
                    // Not running, not completed, no error - just reset
                    btn.disabled = false;
                    indicator.textContent = '';
                    indicator.classList.remove('active');
                    if (statusPollInterval) {
                        clearInterval(statusPollInterval);
                        statusPollInterval = null;
                    }
                }
            } catch (error) {
                console.error('Error polling status:', error);
            }
        }

        // --- Follow-up selection & send logic ---

        function toggleSelection(checkbox) {
            const key = checkbox.dataset.key;
            if (checkbox.checked) {
                selectedSet.add(key);
            } else {
                selectedSet.delete(key);
            }
            updateFollowupBar();
        }

        function updateFollowupBar() {
            const bar = document.getElementById('followup-bar');
            const count = selectedSet.size;
            document.getElementById('selection-count').textContent =
                `${count} candidate${count !== 1 ? 's' : ''} selected`;
            bar.classList.toggle('visible', count > 0);

            // Hide preview panel if nothing selected
            if (count === 0) {
                closeFollowupPanel();
            }
        }

        function clearSelections() {
            selectedSet.clear();
            document.querySelectorAll('#table-body input[type="checkbox"]').forEach(cb => cb.checked = false);
            updateFollowupBar();
        }

        function getSelectedSubmissions() {
            return allData.filter(s => selectedSet.has(submissionKey(s)));
        }

        function groupByChannel(submissions) {
            const grouped = {};
            submissions.forEach(s => {
                if (!grouped[s.channel_name]) {
                    grouped[s.channel_name] = { channel_id: s.channel_id, candidates: [] };
                }
                grouped[s.channel_name].candidates.push(s);
            });
            return grouped;
        }

        function buildFollowupMessage(candidates) {
            const lines = ['Quick status check on candidates currently in process:'];
            candidates
                .sort((a, b) => a.candidate_name.localeCompare(b.candidate_name))
                .forEach(c => {
                    lines.push(`– ${c.candidate_name} (${c.days_since_submission} days)`);
                });
            lines.push('');
            lines.push('Any updates on where things stand with each? Appreciate it!');
            return lines.join('\n');
        }

        function showFollowupPreview() {
            const selected = getSelectedSubmissions();
            if (selected.length === 0) return;

            const grouped = groupByChannel(selected);
            const container = document.getElementById('followup-messages');
            container.innerHTML = '';

            Object.keys(grouped).sort().forEach(channelName => {
                const { channel_id, candidates } = grouped[channelName];
                const message = buildFollowupMessage(candidates);

                const block = document.createElement('div');
                block.className = 'channel-message-block';
                block.innerHTML = `
                    <h3>#${escapeHtml(channelName)} (${candidates.length} candidate${candidates.length !== 1 ? 's' : ''})</h3>
                    <textarea id="msg-${escapeHtml(channel_id)}" data-channel-id="${escapeHtml(channel_id)}" data-channel-name="${escapeHtml(channelName)}">${escapeHtml(message)}</textarea>
                    <div class="channel-send-row">
                        <span class="send-status" id="status-${escapeHtml(channel_id)}"></span>
                        <button class="channel-send-btn" id="btn-${escapeHtml(channel_id)}" onclick="sendFollowup('${escapeHtml(channel_id)}')">Send to #${escapeHtml(channelName)}</button>
                    </div>
                `;
                container.appendChild(block);
            });

            // Reset send-all state
            document.getElementById('send-all-status').textContent = '';
            document.getElementById('send-all-btn').disabled = false;
            document.getElementById('send-all-btn').textContent = 'Send All';

            document.getElementById('followup-panel').classList.add('visible');
            document.getElementById('followup-panel').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function closeFollowupPanel() {
            document.getElementById('followup-panel').classList.remove('visible');
        }

        function clearChannelFromSelection(channelId) {
            // Remove this channel's candidates from selectedSet and uncheck in table
            const toRemove = allData.filter(s => s.channel_id === channelId && selectedSet.has(submissionKey(s)));
            toRemove.forEach(s => selectedSet.delete(submissionKey(s)));

            document.querySelectorAll('#table-body input[type="checkbox"]').forEach(cb => {
                if (!selectedSet.has(cb.dataset.key)) {
                    cb.checked = false;
                }
            });

            // Remove the channel block from the preview panel
            const block = document.getElementById(`msg-${channelId}`);
            if (block) {
                block.closest('.channel-message-block').remove();
            }

            // If no blocks remain, close the panel
            const remaining = document.querySelectorAll('#followup-messages .channel-message-block');
            if (remaining.length === 0) {
                closeFollowupPanel();
            }

            updateFollowupBar();
        }

        async function sendFollowup(channelId) {
            const textarea = document.getElementById(`msg-${channelId}`);
            const btn = document.getElementById(`btn-${channelId}`);
            const statusEl = document.getElementById(`status-${channelId}`);
            const message = textarea.value.trim();

            if (!message) {
                statusEl.textContent = 'Message is empty';
                statusEl.className = 'send-status error';
                return false;
            }

            btn.disabled = true;
            btn.textContent = 'Sending...';
            statusEl.textContent = '';

            try {
                const response = await fetch('/api/send-followup', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ channel_id: channelId, message }),
                });
                const result = await response.json();

                if (result.ok) {
                    // Clear this channel from the panel and selections after a brief flash
                    btn.textContent = 'Sent!';
                    btn.classList.add('sent');
                    statusEl.textContent = '✓ Message sent';
                    statusEl.className = 'send-status success';

                    setTimeout(() => clearChannelFromSelection(channelId), 600);
                    return true;
                } else {
                    btn.textContent = 'Retry';
                    btn.disabled = false;
                    statusEl.textContent = `Error: ${result.error}`;
                    statusEl.className = 'send-status error';
                    return false;
                }
            } catch (err) {
                btn.textContent = 'Retry';
                btn.disabled = false;
                statusEl.textContent = `Error: ${err.message}`;
                statusEl.className = 'send-status error';
                return false;
            }
        }

        async function sendAllFollowups() {
            const sendAllBtn = document.getElementById('send-all-btn');
            const sendAllStatus = document.getElementById('send-all-status');
            const textareas = [...document.querySelectorAll('#followup-messages textarea')];

            sendAllBtn.disabled = true;
            sendAllBtn.textContent = 'Sending...';
            sendAllStatus.textContent = '';

            let successCount = 0;
            let totalCount = textareas.length;

            for (const textarea of textareas) {
                const channelId = textarea.dataset.channelId;
                // textarea may have been removed by a previous send's cleanup
                if (!document.getElementById(`btn-${channelId}`)) {
                    successCount++;
                    continue;
                }
                const ok = await sendFollowup(channelId);
                if (ok) successCount++;
            }

            if (successCount === totalCount) {
                sendAllStatus.textContent = `✓ ${successCount} message${successCount !== 1 ? 's' : ''} sent`;
                sendAllStatus.className = 'send-status success';
                // Panel will auto-close as channels are cleared
            } else {
                sendAllBtn.textContent = 'Retry Failed';
                sendAllBtn.disabled = false;
                sendAllStatus.textContent = `${successCount}/${totalCount} sent`;
                sendAllStatus.className = 'send-status error';
            }
        }

        // --- AI Enrichment ---

        function renderAiStatusCell(submission) {
            if (!submission.ai_summary) {
                return '<span style="color: #ccc; font-size: 12px;">—</span>';
            }

            // Split on bullet points and render as a list
            const raw = submission.ai_summary;
            const bullets = raw.split(/\n/).filter(l => l.trim());
            let html;
            if (bullets.length > 1 || raw.includes('•')) {
                const items = bullets
                    .map(b => b.replace(/^[\s•\-]+/, '').trim())
                    .filter(b => b)
                    .map(b => `<li>${escapeHtml(b)}</li>`)
                    .join('');
                html = `<ul class="ai-summary-list">${items}</ul>`;
            } else {
                html = `<div class="ai-summary-text">${escapeHtml(raw)}</div>`;
            }

            if (submission.ai_enriched_at) {
                const d = new Date(submission.ai_enriched_at);
                html += `<div class="ai-enriched-at">enriched ${d.toLocaleDateString()}</div>`;
            }
            return html;
        }

        let enrichPollInterval = null;
        let lastEnrichReloadAt = 0;      // timestamp of last incremental table reload
        let lastEnrichReloadCount = 0;   // number of completed candidates at last reload

        async function startEnrichment() {
            const btn = document.getElementById('enrich-btn');
            const indicator = document.getElementById('enrich-progress');
            const barContainer = document.getElementById('enrich-bar-container');
            const bar = document.getElementById('enrich-bar');

            btn.disabled = true;
            indicator.innerHTML = '<span class="progress-spinner"></span>Starting enrichment...';
            indicator.classList.add('active');
            barContainer.classList.add('active');
            bar.style.width = '0%';
            lastEnrichReloadAt = Date.now();
            lastEnrichReloadCount = 0;

            try {
                const response = await fetch('/api/enrich', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({}),
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error || 'Failed to start enrichment');
                }

                enrichPollInterval = setInterval(pollEnrichStatus, 1500);
                pollEnrichStatus();
            } catch (error) {
                indicator.textContent = `Error: ${error.message}`;
                indicator.classList.remove('active');
                barContainer.classList.remove('active');
                btn.disabled = false;
            }
        }

        async function clearAiSummaries() {
            if (!confirm('Clear all AI summaries? This cannot be undone.')) return;
            try {
                const response = await fetch('/api/enrich/clear', { method: 'POST' });
                const data = await response.json();
                if (data.ok) {
                    await loadData();
                }
            } catch (err) {
                alert('Error clearing summaries: ' + err.message);
            }
        }

        async function pollEnrichStatus() {
            try {
                const response = await fetch('/api/enrich/status');
                const status = await response.json();
                const indicator = document.getElementById('enrich-progress');
                const btn = document.getElementById('enrich-btn');
                const barContainer = document.getElementById('enrich-bar-container');
                const bar = document.getElementById('enrich-bar');

                if (status.running) {
                    const phaseName = status.phase === 'gathering' ? 'Gathering context' :
                                     status.phase === 'analyzing' ? 'Analyzing with Claude' :
                                     status.phase;
                    const progress = status.total > 0 ? ` (${status.current}/${status.total})` : '';
                    const detail = status.detail && status.detail !== 'done' ? `: ${status.detail}` : '';
                    indicator.innerHTML = `<span class="progress-spinner"></span>${phaseName}${progress}${detail}`;
                    indicator.classList.add('active');

                    // Update progress bar
                    if (status.total > 0) {
                        const pct = Math.round((status.current / status.total) * 100);
                        bar.style.width = pct + '%';
                        barContainer.classList.add('active');
                    }

                    // Incremental table refresh: reload every 5 new candidates or 10 seconds
                    const now = Date.now();
                    const newlyCompleted = status.current - lastEnrichReloadCount;
                    const timeSinceReload = now - lastEnrichReloadAt;
                    if (status.phase === 'analyzing' && (newlyCompleted >= 5 || timeSinceReload >= 10000) && status.current > lastEnrichReloadCount) {
                        lastEnrichReloadAt = now;
                        lastEnrichReloadCount = status.current;
                        loadData();
                    }
                } else if (status.completed) {
                    indicator.textContent = `✓ Enrichment complete!`;
                    indicator.classList.remove('active');
                    bar.style.width = '100%';
                    btn.disabled = false;
                    clearInterval(enrichPollInterval);
                    enrichPollInterval = null;

                    // Final reload to show all AI results
                    await loadData();

                    // Fade out the progress bar after a short delay
                    setTimeout(() => {
                        barContainer.classList.remove('active');
                        bar.style.width = '0%';
                    }, 2000);
                } else if (status.error) {
                    indicator.innerHTML = `✗ ${escapeHtml(status.error)}`;
                    indicator.style.color = '#dc2626';
                    indicator.classList.remove('active');
                    barContainer.classList.remove('active');
                    btn.disabled = false;
                    clearInterval(enrichPollInterval);
                    enrichPollInterval = null;
                } else {
                    btn.disabled = false;
                    indicator.textContent = '';
                    indicator.classList.remove('active');
                    barContainer.classList.remove('active');
                    if (enrichPollInterval) {
                        clearInterval(enrichPollInterval);
                        enrichPollInterval = null;
                    }
                }
            } catch (error) {
                console.error('Error polling enrich status:', error);
            }
        }

        // --- Thread side panel ---

        let currentThreadChannelId = null;
        let currentThreadTs = null;
        let channelMembers = [];

        function escapeAttr(text) {
            // Escape single quotes for use inside onclick attribute strings
            return escapeHtml(text).replace(/'/g, '&#39;');
        }

        function parseThreadTsFromUrl(slackUrl) {
            // Extract thread_ts from slack URL query param
            try {
                const url = new URL(slackUrl);
                return url.searchParams.get('thread_ts');
            } catch {
                // Fallback: regex
                const match = slackUrl.match(/thread_ts=([0-9.]+)/);
                return match ? match[1] : null;
            }
        }

        function openThreadPanel(channelId, slackUrl, candidateName, channelName) {
            const panel = document.getElementById('thread-panel');
            const overlay = document.getElementById('thread-overlay');
            const body = document.getElementById('thread-panel-body');
            const title = document.getElementById('thread-panel-title');
            const channel = document.getElementById('thread-panel-channel');
            const slackLink = document.getElementById('thread-slack-link');
            const messageInput = document.getElementById('thread-message-input');
            const sendStatus = document.getElementById('thread-send-status');

            title.textContent = candidateName;
            channel.textContent = '#' + channelName;
            slackLink.href = slackUrl;

            body.innerHTML = '<div class="thread-loading"><span class="progress-spinner"></span> Loading thread...</div>';

            // Reset composer state
            messageInput.value = '';
            sendStatus.textContent = '';
            sendStatus.className = 'thread-send-status';

            panel.classList.add('visible');
            overlay.classList.add('visible');

            const threadTs = parseThreadTsFromUrl(slackUrl);
            if (!threadTs) {
                body.innerHTML = '<div class="thread-error">Could not parse thread ID from URL.</div>';
                return;
            }

            // Store current context for sending messages
            currentThreadChannelId = channelId;
            currentThreadTs = threadTs;

            // Fetch thread messages and channel members in parallel
            fetchThreadMessages(channelId, threadTs);
            fetchChannelMembers(channelId);
        }

        function closeThreadPanel() {
            document.getElementById('thread-panel').classList.remove('visible');
            document.getElementById('thread-overlay').classList.remove('visible');
            currentThreadChannelId = null;
            currentThreadTs = null;
            channelMembers = [];
        }

        // Close on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('thread-panel').classList.contains('visible')) {
                closeThreadPanel();
            }
        });

        async function fetchThreadMessages(channelId, threadTs) {
            const body = document.getElementById('thread-panel-body');

            try {
                const response = await fetch(`/api/thread?channel_id=${encodeURIComponent(channelId)}&thread_ts=${encodeURIComponent(threadTs)}`);
                const data = await response.json();

                if (!response.ok || !data.ok) {
                    body.innerHTML = `<div class="thread-error">Failed to load thread: ${escapeHtml(data.error || 'Unknown error')}</div>`;
                    return;
                }

                const messages = data.messages || [];
                if (messages.length === 0) {
                    body.innerHTML = '<div class="thread-error">No messages found in this thread.</div>';
                    return;
                }

                // Build a user_id -> author lookup for mention resolution
                const userMap = {};
                messages.forEach(m => {
                    if (m.user_id && m.author) userMap[m.user_id] = m.author;
                });

                let html = '';
                const parent = messages[0];
                const replies = messages.slice(1);

                html += renderThreadMessage(parent, true, userMap);

                if (replies.length > 0) {
                    html += `<div class="thread-reply-count">${replies.length} repl${replies.length === 1 ? 'y' : 'ies'}</div>`;
                    replies.forEach(msg => {
                        html += renderThreadMessage(msg, false, userMap);
                    });
                }

                body.innerHTML = html;
            } catch (err) {
                body.innerHTML = `<div class="thread-error">Error: ${escapeHtml(err.message)}</div>`;
            }
        }

        function renderThreadMessage(msg, isParent, userMap) {
            const d = new Date(msg.timestamp);
            const timeStr = d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) +
                ' ' + d.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' });
            const formattedText = formatSlackText(msg.text, userMap);
            return `
                <div class="thread-msg ${isParent ? 'parent-msg' : ''}">
                    <span class="thread-msg-author">${escapeHtml(msg.author)}</span>
                    <span class="thread-msg-time">${timeStr}</span>
                    <div class="thread-msg-text">${formattedText}</div>
                </div>`;
        }

        function formatSlackText(text, userMap) {
            if (!text) return '';

            // Escape HTML first
            let s = escapeHtml(text);

            // Slack links: <url|label> or <url>
            s = s.replace(/&lt;(https?:\/\/[^|&>]+)\|([^&>]+)&gt;/g, '<a href="$1" target="_blank">$2</a>');
            s = s.replace(/&lt;(https?:\/\/[^&>]+)&gt;/g, '<a href="$1" target="_blank">$1</a>');

            // User mentions: <@U12345>
            s = s.replace(/&lt;@(U[A-Z0-9]+)&gt;/g, (match, uid) => {
                const name = userMap[uid] || uid;
                return `<span class="slack-mention">@${escapeHtml(name)}</span>`;
            });

            // Channel mentions: <#C12345|channel-name>
            s = s.replace(/&lt;#C[A-Z0-9]+\|([^&>]+)&gt;/g, '<span class="slack-mention">#$1</span>');

            // Inline code: `code`
            s = s.replace(/`([^`]+)`/g, '<span class="slack-code">$1</span>');

            // Bold: *text*
            s = s.replace(/(?<![\\w])\*([^*\n]+)\*(?![\\w])/g, '<span class="slack-bold">$1</span>');

            // Italic: _text_
            s = s.replace(/(?<![\\w])_([^_\n]+)_(?![\\w])/g, '<span class="slack-italic">$1</span>');

            return s;
        }

        // --- Channel members and messaging ---

        async function fetchChannelMembers(channelId) {
            try {
                const response = await fetch(`/api/channel-members?channel_id=${encodeURIComponent(channelId)}`);

                if (!response.ok) {
                    const text = await response.text();
                    console.error('Failed to fetch channel members:', response.status, text);
                    return;
                }

                const data = await response.json();

                if (data.ok && data.members) {
                    channelMembers = data.members;
                } else if (data.error) {
                    console.error('API error fetching channel members:', data.error);
                }
            } catch (err) {
                console.error('Error fetching channel members:', err);
            }
        }

        async function sendThreadMessage() {
            if (!currentThreadChannelId || !currentThreadTs) {
                return;
            }

            const messageInput = document.getElementById('thread-message-input');
            const sendBtn = document.getElementById('thread-send-btn');
            const sendStatus = document.getElementById('thread-send-status');
            const message = messageInput.value.trim();

            if (!message) {
                sendStatus.textContent = 'Message cannot be empty';
                sendStatus.className = 'thread-send-status error';
                return;
            }

            sendBtn.disabled = true;
            sendBtn.textContent = 'Sending...';
            sendStatus.textContent = '';

            try {
                const response = await fetch('/api/send-thread-reply', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        channel_id: currentThreadChannelId,
                        thread_ts: currentThreadTs,
                        message: message,
                    }),
                });
                const result = await response.json();

                if (result.ok) {
                    sendStatus.textContent = '✓ Message sent';
                    sendStatus.className = 'thread-send-status success';
                    messageInput.value = '';
                    sendBtn.textContent = 'Send';
                    sendBtn.disabled = false;

                    // Reload thread messages to show the new message
                    setTimeout(() => {
                        fetchThreadMessages(currentThreadChannelId, currentThreadTs);
                        sendStatus.textContent = '';
                    }, 1000);
                } else {
                    sendBtn.textContent = 'Send';
                    sendBtn.disabled = false;
                    sendStatus.textContent = `Error: ${result.error}`;
                    sendStatus.className = 'thread-send-status error';
                }
            } catch (err) {
                sendBtn.textContent = 'Send';
                sendBtn.disabled = false;
                sendStatus.textContent = `Error: ${err.message}`;
                sendStatus.className = 'thread-send-status error';
            }
        }

        // --- Mention autocomplete ---

        let mentionAutocompleteVisible = false;
        let mentionAutocompleteIndex = -1;
        let mentionSearchStart = -1;

        function setupMentionAutocomplete() {
            const messageInput = document.getElementById('thread-message-input');
            const autocomplete = document.getElementById('mention-autocomplete');

            messageInput.addEventListener('input', (e) => {
                handleMentionInput(e.target);
            });

            messageInput.addEventListener('keydown', (e) => {
                if (!mentionAutocompleteVisible) return;

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const options = autocomplete.querySelectorAll('.mention-option');
                    mentionAutocompleteIndex = Math.min(mentionAutocompleteIndex + 1, options.length - 1);
                    updateMentionSelection();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    mentionAutocompleteIndex = Math.max(mentionAutocompleteIndex - 1, 0);
                    updateMentionSelection();
                } else if (e.key === 'Enter' && mentionAutocompleteVisible) {
                    e.preventDefault();
                    const options = autocomplete.querySelectorAll('.mention-option');
                    if (options[mentionAutocompleteIndex]) {
                        selectMention(options[mentionAutocompleteIndex].dataset.userId, options[mentionAutocompleteIndex].dataset.userName);
                    }
                } else if (e.key === 'Escape') {
                    hideMentionAutocomplete();
                }
            });

            // Click outside to close
            document.addEventListener('click', (e) => {
                if (!autocomplete.contains(e.target) && e.target !== messageInput) {
                    hideMentionAutocomplete();
                }
            });
        }

        function handleMentionInput(input) {
            const text = input.value;
            const cursorPos = input.selectionStart;

            // Find the last @ before cursor that's either at start or preceded by whitespace
            let searchStart = -1;
            for (let i = cursorPos - 1; i >= 0; i--) {
                if (text[i] === '@') {
                    // Check if @ is at start or preceded by whitespace
                    if (i === 0 || text[i-1] === ' ' || text[i-1] === '\n') {
                        searchStart = i;
                        break;
                    }
                }
                if (text[i] === ' ' || text[i] === '\n') {
                    break;
                }
            }

            if (searchStart === -1) {
                hideMentionAutocomplete();
                return;
            }

            const searchTerm = text.substring(searchStart + 1, cursorPos).toLowerCase();
            mentionSearchStart = searchStart;

            // If no members loaded yet, hide autocomplete
            if (channelMembers.length === 0) {
                hideMentionAutocomplete();
                return;
            }

            // Filter members
            const matches = channelMembers.filter(m =>
                m.name.toLowerCase().includes(searchTerm)
            ).slice(0, 10);

            if (matches.length === 0) {
                hideMentionAutocomplete();
                return;
            }

            showMentionAutocomplete(matches, input);
        }

        function showMentionAutocomplete(matches, input) {
            const autocomplete = document.getElementById('mention-autocomplete');

            autocomplete.innerHTML = matches.map((m, idx) => `
                <div class="mention-option ${idx === 0 ? 'selected' : ''}"
                     data-user-id="${escapeHtml(m.id)}"
                     data-user-name="${escapeHtml(m.name)}">
                    <div class="mention-option-name">@${escapeHtml(m.name)}</div>
                </div>
            `).join('');

            // Add click handlers
            autocomplete.querySelectorAll('.mention-option').forEach(option => {
                option.addEventListener('click', function() {
                    selectMention(this.dataset.userId, this.dataset.userName);
                });
            });

            autocomplete.classList.add('visible');
            mentionAutocompleteVisible = true;
            mentionAutocompleteIndex = 0;
        }

        function hideMentionAutocomplete() {
            const autocomplete = document.getElementById('mention-autocomplete');
            autocomplete.classList.remove('visible');
            mentionAutocompleteVisible = false;
            mentionAutocompleteIndex = -1;
            mentionSearchStart = -1;
        }

        function updateMentionSelection() {
            const options = document.querySelectorAll('.mention-option');
            options.forEach((opt, idx) => {
                opt.classList.toggle('selected', idx === mentionAutocompleteIndex);
            });
        }

        function selectMention(userId, userName) {
            const messageInput = document.getElementById('thread-message-input');
            const text = messageInput.value;
            const cursorPos = messageInput.selectionStart;

            // Replace from @ to cursor with the mention
            const before = text.substring(0, mentionSearchStart);
            const after = text.substring(cursorPos);
            const mention = `<@${userId}>`;

            messageInput.value = before + mention + after;

            // Move cursor after the mention
            const newCursorPos = before.length + mention.length;
            messageInput.setSelectionRange(newCursorPos, newCursorPos);
            messageInput.focus();

            hideMentionAutocomplete();
        }

        // Initialize mention autocomplete
        setupMentionAutocomplete();

        // Load data and check Ashby config on page load
        loadData();
        checkAshbyStatus();
    </script>
</body>
</html>

